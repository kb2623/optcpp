#include"jsop.hpp"

void jSOp::run_ind(int id) {
    int random_selected_arc_ind;
    double mu_sf, mu_cr;
    int random_selected_period;
    int p_best_ind;
    double temp_sum_sf, temp_sum_cr, sum, weight;
    int s = pop_size / no_thr;
    while (nfes < func->max_num_evaluations) {
        for (int i = s * id; i < pop_size && i < s * (id + 1); i++) sorted_array[i] = i;
        for (int i = s * id; i < pop_size && i < s * (id + 1); i++) temp_fit[i] = fitness[i];
        if (id == 0) sortIndexWithQuickSort(&temp_fit[0], 0, pop_size - 1, sorted_array);
        sync_threads->arrive_and_wait();
        for (int target = s * id; target < pop_size && target < s * (id + 1); target++) {
            //In each generation, CR_i and F_i used by each individual x_i are generated by first selecting an index r_i randomly from [1, H]
            random_selected_period = rand() % memory_size;
            if(random_selected_period == memory_size - 1) {
                mu_sf = 0.9, mu_cr = 0.9;
            } else {
                mu_sf = memory_sf[random_selected_period];
                mu_cr = memory_cr[random_selected_period];
            }
            //generate CR_i and repair its value
            if (mu_cr < 0) {            // JANEZ
                pop_cr[target] = 0.0;     // LSHADE 0
            } else {
                pop_cr[target] = gauss(mu_cr, 0.1);
                if (pop_cr[target] > 1) pop_cr[target] = 1;
                else if (pop_cr[target] < 0) pop_cr[target] = 0;
            }
            if (nfes < 0.25 * func->max_num_evaluations && pop_cr[target] < 0.7) pop_cr[target] = 0.7;    // jSO
            if (nfes < 0.50 * func->max_num_evaluations && pop_cr[target] < 0.6) pop_cr[target] = 0.6;    // jSO
            //generate F_i and repair its value
            do {
                pop_sf[target] = cauchy_g(mu_sf, 0.1);
            } while (pop_sf[target] <= 0.0);
            if (pop_sf[target] > 1) pop_sf[target] = 1.0;
            if (nfes< 0.6 * func->max_num_evaluations && pop_sf[target] > 0.7) pop_sf[target] = 0.7;    // jSO
            //p-best individual is randomly selected from the top pop_size *  p_i members
            do {
                auto ind = p_num == 0 ? 0 : rand() % p_num;
                p_best_ind = sorted_array[ind];
            } while (nfes < 0.50 * func->max_num_evaluations && p_best_ind == target);                   // iL-SHADE
            operateCurrentToPBest1BinWithArchive(pop, &children[target][0], target, p_best_ind, pop_sf[target], pop_cr[target], archive, arc_ind_count);
        }
        // evaluate the children's fitness values
        for (int i = s * id; i < pop_size && i < s * (id + 1); i++) children_fitness[i] = eval(children[i]);
        sync_threads->arrive_and_wait();
        //generation alternation
        for (int i = s * id; i < pop_size && i < s * (id + 1); i++) {
            if (children_fitness[i] == fitness[i]) {
                fitness[i] = children_fitness[i];
                for (int j = 0; j < func->dim; j ++) pop[i][j] = children[i][j];
            } else if (children_fitness[i] < fitness[i]) {
                dif_fitness.push_back(fabs(fitness[i] - children_fitness[i]));
                fitness[i] = children_fitness[i];
                //successful parameters are preserved in S_F and S_CR
                success_sf.push_back(pop_sf[i]);
                success_cr.push_back(pop_cr[i]);
                //parent vectors x_i which were worse than the trial vectors u_i are preserved
                if (arc_size > 1) {
                    if (arc_ind_count < arc_size) {
                        for (int j = 0; j < func->dim; j++) archive[arc_ind_count][j] = pop[i][j];
                        arc_ind_count++;
                    } else { //Whenever the size of the archive exceeds, randomly selected elements are deleted to make space for the newly inserted elements
                        random_selected_arc_ind = rand() % arc_size;
                        for (int j = 0; j < func->dim; j++) archive[random_selected_arc_ind][j] = pop[i][j];
                    }
                }
                for (int j = 0; j < func->dim; j ++) pop[i][j] = children[i][j];    // jSO
            }
        }
        sync_threads->arrive_and_wait();
        if (id == 0) {
            old_num_success_params = num_success_params;
            num_success_params = success_sf.size();
            // if numeber of successful parameters > 0, historical memories are updated
            if (num_success_params > 0) {
                double old_sf, old_cr;     // Janez
                old_sf = memory_sf[memory_pos];
                old_cr = memory_cr[memory_pos];
                memory_sf[memory_pos] = 0;
                memory_cr[memory_pos] = 0;
                temp_sum_sf = 0;
                temp_sum_cr = 0;
                sum = 0;
                for (int i = 0; i < num_success_params; i++) sum += dif_fitness[i];
                //weighted lehmer mean
                for (int i = 0; i < num_success_params; i++) {
                    weight = dif_fitness[i] / sum;
                    memory_sf[memory_pos] += weight * success_sf[i] * success_sf[i];
                    temp_sum_sf += weight * success_sf[i];
                    memory_cr[memory_pos] += weight * success_cr[i] * success_cr[i];
                    temp_sum_cr += weight * success_cr[i];
                }
                memory_sf[memory_pos] /= temp_sum_sf;
                if (temp_sum_cr == 0 || memory_cr[memory_pos] == -1) memory_cr[memory_pos] = -1;
                else memory_cr[memory_pos] /= temp_sum_cr;
                //JANEZ
                memory_sf[memory_pos] = (memory_sf[memory_pos] + old_sf) / 2.0;
                memory_cr[memory_pos] = (memory_cr[memory_pos] + old_cr) / 2.0;
                //increment the counter
                memory_pos++;
                if (memory_pos >= memory_size) memory_pos = 0;
                //clear out the S_F, S_CR and delta fitness
                success_sf.clear();
                success_cr.clear();
                dif_fitness.clear();
            }
            // calculate the population size in the next generation
            plan_pop_size = round((((min_pop_size - max_pop_size) / double(func->max_num_evaluations)) * nfes) + max_pop_size);
            if (pop_size > plan_pop_size) {
                reduction_ind_num = pop_size - plan_pop_size;
                if (pop_size - reduction_ind_num <  min_pop_size) reduction_ind_num = pop_size - min_pop_size;
                reducePopulationWithSort(pop, fitness);
                // resize the archive size
                arc_size = pop_size * arc_rate;
                if (arc_ind_count > arc_size) arc_ind_count = arc_size;
                // resize the number of p-best individuals
                p_best_rate = p_best_rate * (1.0 - 0.5 * nfes /  double(func->max_num_evaluations));   // JANEZ
                p_num = round(pop_size * p_best_rate);
                if (p_num <= 1)  p_num = 2;
            }
        }
        sync_threads->arrive_and_wait();
    }
}

void jSOp::initRun(TestFuncBounds *ifunc) {
    jSO::initRun(ifunc);
    pop = std::vector<double*>(pop_size), children = std::vector<double*>(pop_size);
    fitness = std::vector<double>(pop_size, 0), children_fitness = std::vector<double>(pop_size, 0);
    for (int i = 0; i < pop_size; i++) {
        pop.push_back(makeNewIndividual());
        children.push_back(new double[func->dim]);
    }
    archive = std::vector<double*>();
    for (int i = 0; i < arc_size; i++) archive.push_back(new double[func->dim]);
    success_sf = std::vector<double>(), success_cr = std::vector<double>(), dif_fitness = std::vector<double>();
    memory_sf = std::vector<double>(memory_size, 0.3), memory_cr = vector<double>(memory_size, 0.8);
    pop_sf = new double[pop_size], pop_cr = new double[pop_size];
    sorted_array = new int[pop_size];
    temp_fit = new double[pop_size];
    sync_threads = new std::barrier(no_thr);
    max_pop_size = pop_size;
    p_num = round(pop_size * p_best_rate);
    arc_ind_count = 0;
    num_success_params = 0;
    old_num_success_params = 0;
}

std::tuple<double, std::vector<double>> jSOp::run(TestFuncBounds* func) {
    initRun(func);
    auto threads = std::vector<std::thread>();
    for (int i = 1; i < no_thr; i++) threads.emplace_back(std::thread(&jSOp::run_ind, this, i));
    run_ind(0);
    for (int i = 0; i < no_thr - 1; i++) threads[i].join();
    return std::make_tuple(f_best, x_best);
}

void jSOp::clean() {
    delete[] pop_sf;
    delete[] pop_cr;
    for (int i = 0; i < pop_size; i++) {
        delete[] pop[i]; //.clear();  // JANEZ
        delete[] children[i]; //.clear();  // JANEZ
    }
    pop.clear();  // JANEZ
    children.clear();  // JANEZ
    fitness.clear();
    children_fitness.clear();
    for (int i = 0; i < arc_size; i++) delete[] archive[i];
    archive.clear();
    memory_sf.clear();
    delete[] sorted_array;
    delete[] temp_fit; //.clear();
    delete sync_threads;
}
